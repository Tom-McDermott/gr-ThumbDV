


# Override the base class stop method to close the serial port when the
# flowgraph is terminated

#    def stop(self):
#        if(self.port):
#            self.port.close()
#        super(stop, self)
#        return


''' PMT methods and function calls...

         to create numpy array...
         dat = np.array([1,2,3,4,5,6,7,8], dtype=np.uint8)
         pmtdat = pmt.to_pmt(dat)

         probably don't need these ...
         msg = pmt.make_u8vector(9, single-fill-byte-will-be-replicated)
         In C++ :
           pmt_t pmt::init_u8vector(size_t k, const uint8_t * data) 	
           pmt_t pmt::vector_ref(pmt_t	vector,	size_t k)  #specific element
	   const uint8_t* pmt::u8vector_elements(pmt_t v, size_t & len)
        
         Use these generic casts instead:     	
        
           a_pmt_obj = pmt.to_pmt(a_python_obj) # converts python object to pmt
           a_python_obj = pmt.to_python(a_pmt_obj)  # converts pmt to python object
        
           conversions: None, bool, string, int, float, complex, dict,
           list, tuple, numpy arrays
        
           numpy.dtype(numpy.uint8)   or  numpy.byte
        

         convert the msg into a numpy array, thence to pmt
         unless msg is already an np.array ....
         dat = np.array(msg, dtype=uint8)
         pmt_msg = pmt.to_pmt(dat)
         self.message_port_pub(pmt.intern('msg_out'), pmt_msg)


DVSI3000 packet message format (without parity)

The Texas Instruments TLV320AIC14 CODEC datasheet indicates that the 16-bit
linear mode is 2'S complement formatted. The DVSI datasheet is mute on
this subject.



COMMAND PACKET
Start byte = 0x61 - one byte
Length bytes of just the payload portion = MSLen LSLen - two bytes
Type byte = TT - one byte
Payload bytes = XX - num bytes specified by the length field

Type - 0x00 - Control packet see PP 6.6.1 for table of controls
Type = 0x01 - Channel data (unencoded audio) I/O
Type = 0x02 - Speech Data (encoded audio) I/O

Channel Data Speech Fields - see PP 6.7.1
Uncompandered speech data is 16-bit binary PCM samples (2's complement)

------------
Example: SetDSTAR: 61 00 0d 00 0a 01 30 07 63 40 00 00 00 00 00 00 48
--> Control packet of 13 bytes 

0x0A : PKT_RATEP - Select custom rate for current channel, with registers:
RCW0 = 0x0130 -|
RCW1 = 0x0763 -|
RCW2 = 0x4000 -|-- matches line in table 116 PP 7.3
RCW3 = 0x0000 -|   to set 3600 BPS total composed of 2400 speech + 1200 FEC
RCW4 = 0x0000 -|   identified as DSTAR compatible in note 2
RCW5 = 0x0048 -|

The response to the command should be:
0x61 0x00 0x01 0x00 0x00  --> Control packet of len 1 with value 0x00
   (success).

-------------
Example: Decode AMBE: 61 00 0B 01 01 48  +  the AMBE data to be decoded
--> Channel data = 0x01 
    Message length of 11 bytes:
      CHAND type  = 0x01   (Hard Decision FEC Decode)
      0x48 bits to be decoded ( = 72 bits = 9 bytes)
      Then those 9 bytes must be appended


Response to an decode DSTAR command:  response length is 326 bytes
0x61 0x01 0x42 0x02 0x00 0xa0 0x00 0x00 0x00 0x00 ...

response --  Channel is 02  (PCM audio samples)
         --     322 bytes in the data field
         --     0x00   0xa0 = 160 voice samples  (2 bytes per sample)
         --     encoded 2's complement int16




----------------------
Pyserial 3.0.1 - methods to send, receive, look at buffers, etc.
Python2 uses pyserial 3.0.1   (Python3 uses pyserial 3.4)

* Transmit is blocking unless transmit timeout is set (defaults to zero).
* Receive timeout=0.0 is non-blocking, returns zero or more up to requested
  bytes
* inWaiting  number of bytes waiting to be read from serial input buffer
* outWaiting  number of bytes in the serial output buffer

The buffer seems to be 1020 bytes (but is OS dependent).


__init__(port=None, baudrate=9600, bytesize=EIGHTBITS, parity=PARITY_NONE,
   stopbits=STOPBITS_ONE, timeout=None, xonxoff=False, rtscts=False,
   write_timeout=None, dsrdtr=False, inter_byte_timeout=None)

timeout has same symantics for both timeout and write_timeout

timeout = None: wait forever / until requested number of bytes are received
timeout = 0: non-blocking mode, return immediately in any case, returning
   zero or more, up to the requested number of bytes
timeout = x: set timeout to x seconds (float allowed) returns immediately
   when the requested number of bytes are available, otherwise wait until
   the timeout expires and return all bytes that were received until then.




read(size=1)

        :param size: Number of bytes to read.
        :return: Bytes read from the port.
        :rtype: bytes

        Read *size* bytes from the serial port. If a timeout is set it may
        return less characters as requested. With no timeout it will block
        until the requested number of bytes is read.


readinto(b)

        :param b: bytearray or array instance
        :return: Number of byte read

        Read up to len(b) bytes into :class:`bytearray` *b* and return the
        number of bytes read.


write(data)

        :param data: Data to send.
        :return: Number of bytes written.
        :rtype: int
        :exception SerialTimeoutException:
            In case a write timeout is configured for the port and the time is
            exceeded.

        Write the bytes *data* to the port. This should be of type ``bytes``
        (or compatible such as ``bytearray`` or ``memoryview``). Unicode
        strings must be encoded (e.g. ``'hello'.encode('utf-8'``).

 
 flush()

        Flush of file like objects. In this case, wait until all data is
        written.

 attribute:: in_waiting

        :getter: Get the number of bytes in the input buffer
        :type: int

        Return the number of bytes in the receive buffer.

 
 attribute:: out_waiting

        :getter: Get the number of bytes in the output buffer
        :type: int
        :platform: Posix
        :platform: Windows

        Return the number of bytes in the output buffer.


reset_input_buffer()

        Flush input buffer, discarding all it's contents.


reset_output_buffer()

        Clear output buffer, aborting the current output and
        discarding all that is in the buffer.


to_bytes(sequence)

    :param sequence: bytes, bytearray or memoryview
    :returns: an instance of ``bytes``

    Convert a sequence to a ``bytes`` type. This is used to write code that is
    compatible to Python 2.x and 3.x.

    In Python versions prior 3.x, ``bytes`` is a subclass of str. They convert
    ``str([17])`` to ``'[17]'`` instead of ``'\x11'`` so a simple
    ``bytes(sequence)`` doesn't work for all versions of Python.

    This function is used internally and in the unit tests.




'''

    

